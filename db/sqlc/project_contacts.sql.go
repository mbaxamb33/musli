// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: project_contacts.sql

package db

import (
	"context"
	"database/sql"
)

const associateContactWithProject = `-- name: AssociateContactWithProject :one
INSERT INTO project_contacts (
    project_id, contact_id, association_notes
)
VALUES ($1, $2, $3)
RETURNING project_id, contact_id, association_notes
`

type AssociateContactWithProjectParams struct {
	ProjectID        int32          `json:"project_id"`
	ContactID        int32          `json:"contact_id"`
	AssociationNotes sql.NullString `json:"association_notes"`
}

func (q *Queries) AssociateContactWithProject(ctx context.Context, arg AssociateContactWithProjectParams) (ProjectContact, error) {
	row := q.db.QueryRowContext(ctx, associateContactWithProject, arg.ProjectID, arg.ContactID, arg.AssociationNotes)
	var i ProjectContact
	err := row.Scan(&i.ProjectID, &i.ContactID, &i.AssociationNotes)
	return i, err
}

const getProjectContactAssociation = `-- name: GetProjectContactAssociation :one
SELECT project_id, contact_id, association_notes
FROM project_contacts
WHERE project_id = $1 AND contact_id = $2
`

type GetProjectContactAssociationParams struct {
	ProjectID int32 `json:"project_id"`
	ContactID int32 `json:"contact_id"`
}

func (q *Queries) GetProjectContactAssociation(ctx context.Context, arg GetProjectContactAssociationParams) (ProjectContact, error) {
	row := q.db.QueryRowContext(ctx, getProjectContactAssociation, arg.ProjectID, arg.ContactID)
	var i ProjectContact
	err := row.Scan(&i.ProjectID, &i.ContactID, &i.AssociationNotes)
	return i, err
}

const listContactsForProject = `-- name: ListContactsForProject :many
SELECT pc.project_id, pc.contact_id, pc.association_notes,
       c.first_name, c.last_name, c.email, c.job_title
FROM project_contacts pc
JOIN contacts c ON pc.contact_id = c.contact_id
WHERE pc.project_id = $1
ORDER BY c.last_name ASC, c.first_name ASC
LIMIT $2 OFFSET $3
`

type ListContactsForProjectParams struct {
	ProjectID int32 `json:"project_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListContactsForProjectRow struct {
	ProjectID        int32          `json:"project_id"`
	ContactID        int32          `json:"contact_id"`
	AssociationNotes sql.NullString `json:"association_notes"`
	FirstName        sql.NullString `json:"first_name"`
	LastName         sql.NullString `json:"last_name"`
	Email            sql.NullString `json:"email"`
	JobTitle         sql.NullString `json:"job_title"`
}

func (q *Queries) ListContactsForProject(ctx context.Context, arg ListContactsForProjectParams) ([]ListContactsForProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, listContactsForProject, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListContactsForProjectRow
	for rows.Next() {
		var i ListContactsForProjectRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.ContactID,
			&i.AssociationNotes,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.JobTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectsForContact = `-- name: ListProjectsForContact :many
SELECT pc.project_id, pc.contact_id, pc.association_notes,
       p.project_name, p.description
FROM project_contacts pc
JOIN projects p ON pc.project_id = p.project_id
WHERE pc.contact_id = $1
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type ListProjectsForContactParams struct {
	ContactID int32 `json:"contact_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListProjectsForContactRow struct {
	ProjectID        int32          `json:"project_id"`
	ContactID        int32          `json:"contact_id"`
	AssociationNotes sql.NullString `json:"association_notes"`
	ProjectName      string         `json:"project_name"`
	Description      sql.NullString `json:"description"`
}

func (q *Queries) ListProjectsForContact(ctx context.Context, arg ListProjectsForContactParams) ([]ListProjectsForContactRow, error) {
	rows, err := q.db.QueryContext(ctx, listProjectsForContact, arg.ContactID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProjectsForContactRow
	for rows.Next() {
		var i ListProjectsForContactRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.ContactID,
			&i.AssociationNotes,
			&i.ProjectName,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeProjectContactAssociation = `-- name: RemoveProjectContactAssociation :exec
DELETE FROM project_contacts
WHERE project_id = $1 AND contact_id = $2
`

type RemoveProjectContactAssociationParams struct {
	ProjectID int32 `json:"project_id"`
	ContactID int32 `json:"contact_id"`
}

func (q *Queries) RemoveProjectContactAssociation(ctx context.Context, arg RemoveProjectContactAssociationParams) error {
	_, err := q.db.ExecContext(ctx, removeProjectContactAssociation, arg.ProjectID, arg.ContactID)
	return err
}

const updateProjectContactAssociation = `-- name: UpdateProjectContactAssociation :one
UPDATE project_contacts
SET association_notes = $3
WHERE project_id = $1 AND contact_id = $2
RETURNING project_id, contact_id, association_notes
`

type UpdateProjectContactAssociationParams struct {
	ProjectID        int32          `json:"project_id"`
	ContactID        int32          `json:"contact_id"`
	AssociationNotes sql.NullString `json:"association_notes"`
}

func (q *Queries) UpdateProjectContactAssociation(ctx context.Context, arg UpdateProjectContactAssociationParams) (ProjectContact, error) {
	row := q.db.QueryRowContext(ctx, updateProjectContactAssociation, arg.ProjectID, arg.ContactID, arg.AssociationNotes)
	var i ProjectContact
	err := row.Scan(&i.ProjectID, &i.ContactID, &i.AssociationNotes)
	return i, err
}
