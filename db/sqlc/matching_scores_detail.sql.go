// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: matching_scores_detail.sql

package db

import (
	"context"
	"database/sql"
)

const calculateWeightedScore = `-- name: CalculateWeightedScore :one
SELECT 
  SUM(msd.score * mc.weight) / SUM(mc.weight) AS weighted_score
FROM matching_scores_detail msd
JOIN matching_criteria mc ON msd.criteria_id = mc.criteria_id
WHERE msd.project_company_id = $1
`

func (q *Queries) CalculateWeightedScore(ctx context.Context, projectCompanyID int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, calculateWeightedScore, projectCompanyID)
	var weighted_score int32
	err := row.Scan(&weighted_score)
	return weighted_score, err
}

const createMatchingScoreDetail = `-- name: CreateMatchingScoreDetail :one
INSERT INTO matching_scores_detail (
  project_company_id,
  criteria_id,
  score
) VALUES (
  $1, $2, $3
) RETURNING score_detail_id, project_company_id, criteria_id, score, created_at, updated_at
`

type CreateMatchingScoreDetailParams struct {
	ProjectCompanyID int32  `json:"project_company_id"`
	CriteriaID       int32  `json:"criteria_id"`
	Score            string `json:"score"`
}

func (q *Queries) CreateMatchingScoreDetail(ctx context.Context, arg CreateMatchingScoreDetailParams) (MatchingScoresDetail, error) {
	row := q.db.QueryRowContext(ctx, createMatchingScoreDetail, arg.ProjectCompanyID, arg.CriteriaID, arg.Score)
	var i MatchingScoresDetail
	err := row.Scan(
		&i.ScoreDetailID,
		&i.ProjectCompanyID,
		&i.CriteriaID,
		&i.Score,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAllMatchingScoreDetailsForProjectCompany = `-- name: DeleteAllMatchingScoreDetailsForProjectCompany :exec
DELETE FROM matching_scores_detail
WHERE project_company_id = $1
`

func (q *Queries) DeleteAllMatchingScoreDetailsForProjectCompany(ctx context.Context, projectCompanyID int32) error {
	_, err := q.db.ExecContext(ctx, deleteAllMatchingScoreDetailsForProjectCompany, projectCompanyID)
	return err
}

const deleteMatchingScoreDetail = `-- name: DeleteMatchingScoreDetail :exec
DELETE FROM matching_scores_detail
WHERE project_company_id = $1 AND criteria_id = $2
`

type DeleteMatchingScoreDetailParams struct {
	ProjectCompanyID int32 `json:"project_company_id"`
	CriteriaID       int32 `json:"criteria_id"`
}

func (q *Queries) DeleteMatchingScoreDetail(ctx context.Context, arg DeleteMatchingScoreDetailParams) error {
	_, err := q.db.ExecContext(ctx, deleteMatchingScoreDetail, arg.ProjectCompanyID, arg.CriteriaID)
	return err
}

const deleteMatchingScoreDetailById = `-- name: DeleteMatchingScoreDetailById :exec
DELETE FROM matching_scores_detail
WHERE score_detail_id = $1
`

func (q *Queries) DeleteMatchingScoreDetailById(ctx context.Context, scoreDetailID int32) error {
	_, err := q.db.ExecContext(ctx, deleteMatchingScoreDetailById, scoreDetailID)
	return err
}

const getCriteriaScoresForProject = `-- name: GetCriteriaScoresForProject :many
SELECT 
  c.name AS company_name,
  mc.name AS criteria_name,
  msd.score,
  mc.weight,
  (msd.score * mc.weight) AS weighted_score
FROM matching_scores_detail msd
JOIN project_companies pc ON msd.project_company_id = pc.project_company_id
JOIN companies c ON pc.company_id = c.company_id
JOIN matching_criteria mc ON msd.criteria_id = mc.criteria_id
WHERE pc.project_id = $1
ORDER BY c.name, mc.weight DESC
`

type GetCriteriaScoresForProjectRow struct {
	CompanyName   string         `json:"company_name"`
	CriteriaName  string         `json:"criteria_name"`
	Score         string         `json:"score"`
	Weight        sql.NullString `json:"weight"`
	WeightedScore int32          `json:"weighted_score"`
}

func (q *Queries) GetCriteriaScoresForProject(ctx context.Context, projectID int32) ([]GetCriteriaScoresForProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, getCriteriaScoresForProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCriteriaScoresForProjectRow
	for rows.Next() {
		var i GetCriteriaScoresForProjectRow
		if err := rows.Scan(
			&i.CompanyName,
			&i.CriteriaName,
			&i.Score,
			&i.Weight,
			&i.WeightedScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchingScoreDetail = `-- name: GetMatchingScoreDetail :one
SELECT score_detail_id, project_company_id, criteria_id, score, created_at, updated_at FROM matching_scores_detail
WHERE project_company_id = $1 AND criteria_id = $2
LIMIT 1
`

type GetMatchingScoreDetailParams struct {
	ProjectCompanyID int32 `json:"project_company_id"`
	CriteriaID       int32 `json:"criteria_id"`
}

func (q *Queries) GetMatchingScoreDetail(ctx context.Context, arg GetMatchingScoreDetailParams) (MatchingScoresDetail, error) {
	row := q.db.QueryRowContext(ctx, getMatchingScoreDetail, arg.ProjectCompanyID, arg.CriteriaID)
	var i MatchingScoresDetail
	err := row.Scan(
		&i.ScoreDetailID,
		&i.ProjectCompanyID,
		&i.CriteriaID,
		&i.Score,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMatchingScoreDetailById = `-- name: GetMatchingScoreDetailById :one
SELECT score_detail_id, project_company_id, criteria_id, score, created_at, updated_at FROM matching_scores_detail
WHERE score_detail_id = $1
LIMIT 1
`

func (q *Queries) GetMatchingScoreDetailById(ctx context.Context, scoreDetailID int32) (MatchingScoresDetail, error) {
	row := q.db.QueryRowContext(ctx, getMatchingScoreDetailById, scoreDetailID)
	var i MatchingScoresDetail
	err := row.Scan(
		&i.ScoreDetailID,
		&i.ProjectCompanyID,
		&i.CriteriaID,
		&i.Score,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listMatchingScoreDetailsForProjectCompany = `-- name: ListMatchingScoreDetailsForProjectCompany :many
SELECT 
  msd.score_detail_id, msd.project_company_id, msd.criteria_id, msd.score, msd.created_at, msd.updated_at,
  mc.name AS criteria_name,
  mc.description AS criteria_description,
  mc.weight AS criteria_weight
FROM matching_scores_detail msd
JOIN matching_criteria mc ON msd.criteria_id = mc.criteria_id
WHERE msd.project_company_id = $1
ORDER BY mc.weight DESC, mc.name
LIMIT $2 OFFSET $3
`

type ListMatchingScoreDetailsForProjectCompanyParams struct {
	ProjectCompanyID int32 `json:"project_company_id"`
	Limit            int32 `json:"limit"`
	Offset           int32 `json:"offset"`
}

type ListMatchingScoreDetailsForProjectCompanyRow struct {
	ScoreDetailID       int32          `json:"score_detail_id"`
	ProjectCompanyID    int32          `json:"project_company_id"`
	CriteriaID          int32          `json:"criteria_id"`
	Score               string         `json:"score"`
	CreatedAt           sql.NullTime   `json:"created_at"`
	UpdatedAt           sql.NullTime   `json:"updated_at"`
	CriteriaName        string         `json:"criteria_name"`
	CriteriaDescription sql.NullString `json:"criteria_description"`
	CriteriaWeight      sql.NullString `json:"criteria_weight"`
}

func (q *Queries) ListMatchingScoreDetailsForProjectCompany(ctx context.Context, arg ListMatchingScoreDetailsForProjectCompanyParams) ([]ListMatchingScoreDetailsForProjectCompanyRow, error) {
	rows, err := q.db.QueryContext(ctx, listMatchingScoreDetailsForProjectCompany, arg.ProjectCompanyID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMatchingScoreDetailsForProjectCompanyRow
	for rows.Next() {
		var i ListMatchingScoreDetailsForProjectCompanyRow
		if err := rows.Scan(
			&i.ScoreDetailID,
			&i.ProjectCompanyID,
			&i.CriteriaID,
			&i.Score,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CriteriaName,
			&i.CriteriaDescription,
			&i.CriteriaWeight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMatchingScoreDetail = `-- name: UpdateMatchingScoreDetail :one
UPDATE matching_scores_detail
SET
  score = $3,
  updated_at = CURRENT_TIMESTAMP
WHERE project_company_id = $1 AND criteria_id = $2
RETURNING score_detail_id, project_company_id, criteria_id, score, created_at, updated_at
`

type UpdateMatchingScoreDetailParams struct {
	ProjectCompanyID int32  `json:"project_company_id"`
	CriteriaID       int32  `json:"criteria_id"`
	Score            string `json:"score"`
}

func (q *Queries) UpdateMatchingScoreDetail(ctx context.Context, arg UpdateMatchingScoreDetailParams) (MatchingScoresDetail, error) {
	row := q.db.QueryRowContext(ctx, updateMatchingScoreDetail, arg.ProjectCompanyID, arg.CriteriaID, arg.Score)
	var i MatchingScoresDetail
	err := row.Scan(
		&i.ScoreDetailID,
		&i.ProjectCompanyID,
		&i.CriteriaID,
		&i.Score,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
