// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: web_scrape_data.sql

package db

import (
	"context"
	"database/sql"
)

const createWebScrapeData = `-- name: CreateWebScrapeData :one
INSERT INTO web_scrape_data (
  company_id,
  source_url,
  data_type,
  content,
  is_processed
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING scrape_id, company_id, source_url, data_type, content, scrape_date, is_processed
`

type CreateWebScrapeDataParams struct {
	CompanyID   int32          `json:"company_id"`
	SourceUrl   string         `json:"source_url"`
	DataType    string         `json:"data_type"`
	Content     sql.NullString `json:"content"`
	IsProcessed sql.NullBool   `json:"is_processed"`
}

func (q *Queries) CreateWebScrapeData(ctx context.Context, arg CreateWebScrapeDataParams) (WebScrapeDatum, error) {
	row := q.db.QueryRowContext(ctx, createWebScrapeData,
		arg.CompanyID,
		arg.SourceUrl,
		arg.DataType,
		arg.Content,
		arg.IsProcessed,
	)
	var i WebScrapeDatum
	err := row.Scan(
		&i.ScrapeID,
		&i.CompanyID,
		&i.SourceUrl,
		&i.DataType,
		&i.Content,
		&i.ScrapeDate,
		&i.IsProcessed,
	)
	return i, err
}

const deleteAllWebScrapeDataForCompany = `-- name: DeleteAllWebScrapeDataForCompany :exec
DELETE FROM web_scrape_data
WHERE company_id = $1
`

func (q *Queries) DeleteAllWebScrapeDataForCompany(ctx context.Context, companyID int32) error {
	_, err := q.db.ExecContext(ctx, deleteAllWebScrapeDataForCompany, companyID)
	return err
}

const deleteWebScrapeData = `-- name: DeleteWebScrapeData :exec
DELETE FROM web_scrape_data
WHERE scrape_id = $1
`

func (q *Queries) DeleteWebScrapeData(ctx context.Context, scrapeID int32) error {
	_, err := q.db.ExecContext(ctx, deleteWebScrapeData, scrapeID)
	return err
}

const getLatestWebScrapeByType = `-- name: GetLatestWebScrapeByType :one
SELECT scrape_id, company_id, source_url, data_type, content, scrape_date, is_processed FROM web_scrape_data
WHERE company_id = $1 AND data_type = $2
ORDER BY scrape_date DESC
LIMIT 1
`

type GetLatestWebScrapeByTypeParams struct {
	CompanyID int32  `json:"company_id"`
	DataType  string `json:"data_type"`
}

func (q *Queries) GetLatestWebScrapeByType(ctx context.Context, arg GetLatestWebScrapeByTypeParams) (WebScrapeDatum, error) {
	row := q.db.QueryRowContext(ctx, getLatestWebScrapeByType, arg.CompanyID, arg.DataType)
	var i WebScrapeDatum
	err := row.Scan(
		&i.ScrapeID,
		&i.CompanyID,
		&i.SourceUrl,
		&i.DataType,
		&i.Content,
		&i.ScrapeDate,
		&i.IsProcessed,
	)
	return i, err
}

const getWebScrapeData = `-- name: GetWebScrapeData :one
SELECT scrape_id, company_id, source_url, data_type, content, scrape_date, is_processed FROM web_scrape_data
WHERE scrape_id = $1 LIMIT 1
`

func (q *Queries) GetWebScrapeData(ctx context.Context, scrapeID int32) (WebScrapeDatum, error) {
	row := q.db.QueryRowContext(ctx, getWebScrapeData, scrapeID)
	var i WebScrapeDatum
	err := row.Scan(
		&i.ScrapeID,
		&i.CompanyID,
		&i.SourceUrl,
		&i.DataType,
		&i.Content,
		&i.ScrapeDate,
		&i.IsProcessed,
	)
	return i, err
}

const getWebScrapeDataCountByType = `-- name: GetWebScrapeDataCountByType :many
SELECT 
  data_type, 
  COUNT(*) as count
FROM web_scrape_data
WHERE company_id = $1
GROUP BY data_type
ORDER BY count DESC
`

type GetWebScrapeDataCountByTypeRow struct {
	DataType string `json:"data_type"`
	Count    int64  `json:"count"`
}

func (q *Queries) GetWebScrapeDataCountByType(ctx context.Context, companyID int32) ([]GetWebScrapeDataCountByTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getWebScrapeDataCountByType, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWebScrapeDataCountByTypeRow
	for rows.Next() {
		var i GetWebScrapeDataCountByTypeRow
		if err := rows.Scan(&i.DataType, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebScrapeDataTypes = `-- name: GetWebScrapeDataTypes :many
SELECT DISTINCT data_type
FROM web_scrape_data
ORDER BY data_type
`

func (q *Queries) GetWebScrapeDataTypes(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getWebScrapeDataTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var data_type string
		if err := rows.Scan(&data_type); err != nil {
			return nil, err
		}
		items = append(items, data_type)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnprocessedWebScrapeData = `-- name: ListUnprocessedWebScrapeData :many
SELECT scrape_id, company_id, source_url, data_type, content, scrape_date, is_processed FROM web_scrape_data
WHERE is_processed = FALSE
ORDER BY scrape_date
LIMIT $1 OFFSET $2
`

type ListUnprocessedWebScrapeDataParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListUnprocessedWebScrapeData(ctx context.Context, arg ListUnprocessedWebScrapeDataParams) ([]WebScrapeDatum, error) {
	rows, err := q.db.QueryContext(ctx, listUnprocessedWebScrapeData, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WebScrapeDatum
	for rows.Next() {
		var i WebScrapeDatum
		if err := rows.Scan(
			&i.ScrapeID,
			&i.CompanyID,
			&i.SourceUrl,
			&i.DataType,
			&i.Content,
			&i.ScrapeDate,
			&i.IsProcessed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebScrapeDataByType = `-- name: ListWebScrapeDataByType :many
SELECT scrape_id, company_id, source_url, data_type, content, scrape_date, is_processed FROM web_scrape_data
WHERE company_id = $1 AND data_type = $2
ORDER BY scrape_date DESC
LIMIT $3 OFFSET $4
`

type ListWebScrapeDataByTypeParams struct {
	CompanyID int32  `json:"company_id"`
	DataType  string `json:"data_type"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) ListWebScrapeDataByType(ctx context.Context, arg ListWebScrapeDataByTypeParams) ([]WebScrapeDatum, error) {
	rows, err := q.db.QueryContext(ctx, listWebScrapeDataByType,
		arg.CompanyID,
		arg.DataType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WebScrapeDatum
	for rows.Next() {
		var i WebScrapeDatum
		if err := rows.Scan(
			&i.ScrapeID,
			&i.CompanyID,
			&i.SourceUrl,
			&i.DataType,
			&i.Content,
			&i.ScrapeDate,
			&i.IsProcessed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebScrapeDataForCompany = `-- name: ListWebScrapeDataForCompany :many
SELECT scrape_id, company_id, source_url, data_type, content, scrape_date, is_processed FROM web_scrape_data
WHERE company_id = $1
ORDER BY scrape_date DESC
LIMIT $2 OFFSET $3
`

type ListWebScrapeDataForCompanyParams struct {
	CompanyID int32 `json:"company_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

func (q *Queries) ListWebScrapeDataForCompany(ctx context.Context, arg ListWebScrapeDataForCompanyParams) ([]WebScrapeDatum, error) {
	rows, err := q.db.QueryContext(ctx, listWebScrapeDataForCompany, arg.CompanyID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WebScrapeDatum
	for rows.Next() {
		var i WebScrapeDatum
		if err := rows.Scan(
			&i.ScrapeID,
			&i.CompanyID,
			&i.SourceUrl,
			&i.DataType,
			&i.Content,
			&i.ScrapeDate,
			&i.IsProcessed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markWebScrapeDataAsProcessed = `-- name: MarkWebScrapeDataAsProcessed :one
UPDATE web_scrape_data
SET 
  is_processed = TRUE
WHERE scrape_id = $1
RETURNING scrape_id, company_id, source_url, data_type, content, scrape_date, is_processed
`

func (q *Queries) MarkWebScrapeDataAsProcessed(ctx context.Context, scrapeID int32) (WebScrapeDatum, error) {
	row := q.db.QueryRowContext(ctx, markWebScrapeDataAsProcessed, scrapeID)
	var i WebScrapeDatum
	err := row.Scan(
		&i.ScrapeID,
		&i.CompanyID,
		&i.SourceUrl,
		&i.DataType,
		&i.Content,
		&i.ScrapeDate,
		&i.IsProcessed,
	)
	return i, err
}

const updateWebScrapeData = `-- name: UpdateWebScrapeData :one
UPDATE web_scrape_data
SET
  source_url = COALESCE($2, source_url),
  data_type = COALESCE($3, data_type),
  content = COALESCE($4, content),
  is_processed = COALESCE($5, is_processed)
WHERE scrape_id = $1
RETURNING scrape_id, company_id, source_url, data_type, content, scrape_date, is_processed
`

type UpdateWebScrapeDataParams struct {
	ScrapeID    int32          `json:"scrape_id"`
	SourceUrl   string         `json:"source_url"`
	DataType    string         `json:"data_type"`
	Content     sql.NullString `json:"content"`
	IsProcessed sql.NullBool   `json:"is_processed"`
}

func (q *Queries) UpdateWebScrapeData(ctx context.Context, arg UpdateWebScrapeDataParams) (WebScrapeDatum, error) {
	row := q.db.QueryRowContext(ctx, updateWebScrapeData,
		arg.ScrapeID,
		arg.SourceUrl,
		arg.DataType,
		arg.Content,
		arg.IsProcessed,
	)
	var i WebScrapeDatum
	err := row.Scan(
		&i.ScrapeID,
		&i.CompanyID,
		&i.SourceUrl,
		&i.DataType,
		&i.Content,
		&i.ScrapeDate,
		&i.IsProcessed,
	)
	return i, err
}
