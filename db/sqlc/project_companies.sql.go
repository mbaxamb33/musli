// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: project_companies.sql

package db

import (
	"context"
	"database/sql"
)

const getProjectCompany = `-- name: GetProjectCompany :one
SELECT project_company_id, project_id, company_id, matching_score, approach_strategy_id, status, created_at, updated_at FROM project_companies
WHERE project_id = $1 AND company_id = $2
LIMIT 1
`

type GetProjectCompanyParams struct {
	ProjectID int32 `json:"project_id"`
	CompanyID int32 `json:"company_id"`
}

func (q *Queries) GetProjectCompany(ctx context.Context, arg GetProjectCompanyParams) (ProjectCompany, error) {
	row := q.db.QueryRowContext(ctx, getProjectCompany, arg.ProjectID, arg.CompanyID)
	var i ProjectCompany
	err := row.Scan(
		&i.ProjectCompanyID,
		&i.ProjectID,
		&i.CompanyID,
		&i.MatchingScore,
		&i.ApproachStrategyID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectCompanyById = `-- name: GetProjectCompanyById :one
SELECT project_company_id, project_id, company_id, matching_score, approach_strategy_id, status, created_at, updated_at FROM project_companies
WHERE project_company_id = $1
LIMIT 1
`

func (q *Queries) GetProjectCompanyById(ctx context.Context, projectCompanyID int32) (ProjectCompany, error) {
	row := q.db.QueryRowContext(ctx, getProjectCompanyById, projectCompanyID)
	var i ProjectCompany
	err := row.Scan(
		&i.ProjectCompanyID,
		&i.ProjectID,
		&i.CompanyID,
		&i.MatchingScore,
		&i.ApproachStrategyID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectCompanyMatches = `-- name: GetProjectCompanyMatches :many
SELECT 
  pc.project_company_id, pc.project_id, pc.company_id, pc.matching_score, pc.approach_strategy_id, pc.status, pc.created_at, pc.updated_at,
  c.name AS company_name,
  strategy.name AS strategy_name,
  (
    SELECT COUNT(*) 
    FROM matching_scores_detail msd 
    WHERE msd.project_company_id = pc.project_company_id
  ) AS criteria_count
FROM project_companies pc
JOIN companies c ON pc.company_id = c.company_id
LEFT JOIN approach_strategies strategy ON pc.approach_strategy_id = strategy.strategy_id
WHERE pc.project_id = $1
ORDER BY pc.matching_score DESC
LIMIT $2 OFFSET $3
`

type GetProjectCompanyMatchesParams struct {
	ProjectID int32 `json:"project_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type GetProjectCompanyMatchesRow struct {
	ProjectCompanyID   int32          `json:"project_company_id"`
	ProjectID          int32          `json:"project_id"`
	CompanyID          int32          `json:"company_id"`
	MatchingScore      sql.NullString `json:"matching_score"`
	ApproachStrategyID sql.NullInt32  `json:"approach_strategy_id"`
	Status             sql.NullString `json:"status"`
	CreatedAt          sql.NullTime   `json:"created_at"`
	UpdatedAt          sql.NullTime   `json:"updated_at"`
	CompanyName        string         `json:"company_name"`
	StrategyName       sql.NullString `json:"strategy_name"`
	CriteriaCount      int64          `json:"criteria_count"`
}

func (q *Queries) GetProjectCompanyMatches(ctx context.Context, arg GetProjectCompanyMatchesParams) ([]GetProjectCompanyMatchesRow, error) {
	rows, err := q.db.QueryContext(ctx, getProjectCompanyMatches, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectCompanyMatchesRow
	for rows.Next() {
		var i GetProjectCompanyMatchesRow
		if err := rows.Scan(
			&i.ProjectCompanyID,
			&i.ProjectID,
			&i.CompanyID,
			&i.MatchingScore,
			&i.ApproachStrategyID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompanyName,
			&i.StrategyName,
			&i.CriteriaCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsForCompany = `-- name: GetProjectsForCompany :many
SELECT 
  p.project_id, p.user_id, p.name, p.description, p.start_date, p.end_date, p.status, p.created_at, p.updated_at,
  pc.matching_score,
  pc.status AS relationship_status,
  u.username AS owner_username
FROM projects p
JOIN project_companies pc ON p.project_id = pc.project_id
JOIN users u ON p.user_id = u.user_id
WHERE pc.company_id = $1
ORDER BY pc.matching_score DESC
LIMIT $2 OFFSET $3
`

type GetProjectsForCompanyParams struct {
	CompanyID int32 `json:"company_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type GetProjectsForCompanyRow struct {
	ProjectID          int32          `json:"project_id"`
	UserID             int32          `json:"user_id"`
	Name               string         `json:"name"`
	Description        sql.NullString `json:"description"`
	StartDate          sql.NullTime   `json:"start_date"`
	EndDate            sql.NullTime   `json:"end_date"`
	Status             sql.NullString `json:"status"`
	CreatedAt          sql.NullTime   `json:"created_at"`
	UpdatedAt          sql.NullTime   `json:"updated_at"`
	MatchingScore      sql.NullString `json:"matching_score"`
	RelationshipStatus sql.NullString `json:"relationship_status"`
	OwnerUsername      string         `json:"owner_username"`
}

func (q *Queries) GetProjectsForCompany(ctx context.Context, arg GetProjectsForCompanyParams) ([]GetProjectsForCompanyRow, error) {
	rows, err := q.db.QueryContext(ctx, getProjectsForCompany, arg.CompanyID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectsForCompanyRow
	for rows.Next() {
		var i GetProjectsForCompanyRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MatchingScore,
			&i.RelationshipStatus,
			&i.OwnerUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopMatchingCompaniesForProject = `-- name: GetTopMatchingCompaniesForProject :many
SELECT
  c.company_id, c.name, c.industry, c.size, c.location, c.website, c.description, c.created_at, c.updated_at,
  pc.matching_score,
  pc.status
FROM companies c
JOIN project_companies pc ON c.company_id = pc.company_id
WHERE pc.project_id = $1
ORDER BY pc.matching_score DESC
LIMIT $2
`

type GetTopMatchingCompaniesForProjectParams struct {
	ProjectID int32 `json:"project_id"`
	Limit     int32 `json:"limit"`
}

type GetTopMatchingCompaniesForProjectRow struct {
	CompanyID     int32          `json:"company_id"`
	Name          string         `json:"name"`
	Industry      sql.NullString `json:"industry"`
	Size          sql.NullString `json:"size"`
	Location      sql.NullString `json:"location"`
	Website       sql.NullString `json:"website"`
	Description   sql.NullString `json:"description"`
	CreatedAt     sql.NullTime   `json:"created_at"`
	UpdatedAt     sql.NullTime   `json:"updated_at"`
	MatchingScore sql.NullString `json:"matching_score"`
	Status        sql.NullString `json:"status"`
}

func (q *Queries) GetTopMatchingCompaniesForProject(ctx context.Context, arg GetTopMatchingCompaniesForProjectParams) ([]GetTopMatchingCompaniesForProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopMatchingCompaniesForProject, arg.ProjectID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopMatchingCompaniesForProjectRow
	for rows.Next() {
		var i GetTopMatchingCompaniesForProjectRow
		if err := rows.Scan(
			&i.CompanyID,
			&i.Name,
			&i.Industry,
			&i.Size,
			&i.Location,
			&i.Website,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MatchingScore,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkCompanyToProject = `-- name: LinkCompanyToProject :one
INSERT INTO project_companies (
  project_id,
  company_id,
  matching_score,
  approach_strategy_id,
  status
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING project_company_id, project_id, company_id, matching_score, approach_strategy_id, status, created_at, updated_at
`

type LinkCompanyToProjectParams struct {
	ProjectID          int32          `json:"project_id"`
	CompanyID          int32          `json:"company_id"`
	MatchingScore      sql.NullString `json:"matching_score"`
	ApproachStrategyID sql.NullInt32  `json:"approach_strategy_id"`
	Status             sql.NullString `json:"status"`
}

func (q *Queries) LinkCompanyToProject(ctx context.Context, arg LinkCompanyToProjectParams) (ProjectCompany, error) {
	row := q.db.QueryRowContext(ctx, linkCompanyToProject,
		arg.ProjectID,
		arg.CompanyID,
		arg.MatchingScore,
		arg.ApproachStrategyID,
		arg.Status,
	)
	var i ProjectCompany
	err := row.Scan(
		&i.ProjectCompanyID,
		&i.ProjectID,
		&i.CompanyID,
		&i.MatchingScore,
		&i.ApproachStrategyID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listProjectCompanies = `-- name: ListProjectCompanies :many
SELECT
  pc.project_company_id, pc.project_id, pc.company_id, pc.matching_score, pc.approach_strategy_id, pc.status, pc.created_at, pc.updated_at,
  c.name AS company_name,
  c.industry,
  c.size,
  strategy.name AS approach_strategy
FROM project_companies pc
JOIN companies c ON pc.company_id = c.company_id
LEFT JOIN approach_strategies strategy ON pc.approach_strategy_id = strategy.strategy_id
WHERE pc.project_id = $1
ORDER BY pc.matching_score DESC
LIMIT $2 OFFSET $3
`

type ListProjectCompaniesParams struct {
	ProjectID int32 `json:"project_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListProjectCompaniesRow struct {
	ProjectCompanyID   int32          `json:"project_company_id"`
	ProjectID          int32          `json:"project_id"`
	CompanyID          int32          `json:"company_id"`
	MatchingScore      sql.NullString `json:"matching_score"`
	ApproachStrategyID sql.NullInt32  `json:"approach_strategy_id"`
	Status             sql.NullString `json:"status"`
	CreatedAt          sql.NullTime   `json:"created_at"`
	UpdatedAt          sql.NullTime   `json:"updated_at"`
	CompanyName        string         `json:"company_name"`
	Industry           sql.NullString `json:"industry"`
	Size               sql.NullString `json:"size"`
	ApproachStrategy   sql.NullString `json:"approach_strategy"`
}

func (q *Queries) ListProjectCompanies(ctx context.Context, arg ListProjectCompaniesParams) ([]ListProjectCompaniesRow, error) {
	rows, err := q.db.QueryContext(ctx, listProjectCompanies, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProjectCompaniesRow
	for rows.Next() {
		var i ListProjectCompaniesRow
		if err := rows.Scan(
			&i.ProjectCompanyID,
			&i.ProjectID,
			&i.CompanyID,
			&i.MatchingScore,
			&i.ApproachStrategyID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompanyName,
			&i.Industry,
			&i.Size,
			&i.ApproachStrategy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectCompaniesByStatus = `-- name: ListProjectCompaniesByStatus :many
SELECT
  pc.project_company_id, pc.project_id, pc.company_id, pc.matching_score, pc.approach_strategy_id, pc.status, pc.created_at, pc.updated_at,
  c.name AS company_name,
  c.industry,
  c.size,
  strategy.name AS approach_strategy
FROM project_companies pc
JOIN companies c ON pc.company_id = c.company_id
LEFT JOIN approach_strategies strategy ON pc.approach_strategy_id = strategy.strategy_id
WHERE pc.project_id = $1 AND pc.status = $2
ORDER BY pc.matching_score DESC
LIMIT $3 OFFSET $4
`

type ListProjectCompaniesByStatusParams struct {
	ProjectID int32          `json:"project_id"`
	Status    sql.NullString `json:"status"`
	Limit     int32          `json:"limit"`
	Offset    int32          `json:"offset"`
}

type ListProjectCompaniesByStatusRow struct {
	ProjectCompanyID   int32          `json:"project_company_id"`
	ProjectID          int32          `json:"project_id"`
	CompanyID          int32          `json:"company_id"`
	MatchingScore      sql.NullString `json:"matching_score"`
	ApproachStrategyID sql.NullInt32  `json:"approach_strategy_id"`
	Status             sql.NullString `json:"status"`
	CreatedAt          sql.NullTime   `json:"created_at"`
	UpdatedAt          sql.NullTime   `json:"updated_at"`
	CompanyName        string         `json:"company_name"`
	Industry           sql.NullString `json:"industry"`
	Size               sql.NullString `json:"size"`
	ApproachStrategy   sql.NullString `json:"approach_strategy"`
}

func (q *Queries) ListProjectCompaniesByStatus(ctx context.Context, arg ListProjectCompaniesByStatusParams) ([]ListProjectCompaniesByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, listProjectCompaniesByStatus,
		arg.ProjectID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProjectCompaniesByStatusRow
	for rows.Next() {
		var i ListProjectCompaniesByStatusRow
		if err := rows.Scan(
			&i.ProjectCompanyID,
			&i.ProjectID,
			&i.CompanyID,
			&i.MatchingScore,
			&i.ApproachStrategyID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompanyName,
			&i.Industry,
			&i.Size,
			&i.ApproachStrategy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeCompanyFromProject = `-- name: RemoveCompanyFromProject :exec
DELETE FROM project_companies
WHERE project_id = $1 AND company_id = $2
`

type RemoveCompanyFromProjectParams struct {
	ProjectID int32 `json:"project_id"`
	CompanyID int32 `json:"company_id"`
}

func (q *Queries) RemoveCompanyFromProject(ctx context.Context, arg RemoveCompanyFromProjectParams) error {
	_, err := q.db.ExecContext(ctx, removeCompanyFromProject, arg.ProjectID, arg.CompanyID)
	return err
}

const updateProjectCompany = `-- name: UpdateProjectCompany :one
UPDATE project_companies
SET
  matching_score = COALESCE($3, matching_score),
  approach_strategy_id = COALESCE($4, approach_strategy_id),
  status = COALESCE($5, status),
  updated_at = CURRENT_TIMESTAMP
WHERE project_id = $1 AND company_id = $2
RETURNING project_company_id, project_id, company_id, matching_score, approach_strategy_id, status, created_at, updated_at
`

type UpdateProjectCompanyParams struct {
	ProjectID          int32          `json:"project_id"`
	CompanyID          int32          `json:"company_id"`
	MatchingScore      sql.NullString `json:"matching_score"`
	ApproachStrategyID sql.NullInt32  `json:"approach_strategy_id"`
	Status             sql.NullString `json:"status"`
}

func (q *Queries) UpdateProjectCompany(ctx context.Context, arg UpdateProjectCompanyParams) (ProjectCompany, error) {
	row := q.db.QueryRowContext(ctx, updateProjectCompany,
		arg.ProjectID,
		arg.CompanyID,
		arg.MatchingScore,
		arg.ApproachStrategyID,
		arg.Status,
	)
	var i ProjectCompany
	err := row.Scan(
		&i.ProjectCompanyID,
		&i.ProjectID,
		&i.CompanyID,
		&i.MatchingScore,
		&i.ApproachStrategyID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProjectCompanyStatus = `-- name: UpdateProjectCompanyStatus :one
UPDATE project_companies
SET 
  status = $3,
  updated_at = CURRENT_TIMESTAMP
WHERE project_id = $1 AND company_id = $2
RETURNING project_company_id, project_id, company_id, matching_score, approach_strategy_id, status, created_at, updated_at
`

type UpdateProjectCompanyStatusParams struct {
	ProjectID int32          `json:"project_id"`
	CompanyID int32          `json:"company_id"`
	Status    sql.NullString `json:"status"`
}

func (q *Queries) UpdateProjectCompanyStatus(ctx context.Context, arg UpdateProjectCompanyStatusParams) (ProjectCompany, error) {
	row := q.db.QueryRowContext(ctx, updateProjectCompanyStatus, arg.ProjectID, arg.CompanyID, arg.Status)
	var i ProjectCompany
	err := row.Scan(
		&i.ProjectCompanyID,
		&i.ProjectID,
		&i.CompanyID,
		&i.MatchingScore,
		&i.ApproachStrategyID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
