// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: project_companies.sql

package db

import (
	"context"
	"database/sql"
)

const associateCompanyWithProject = `-- name: AssociateCompanyWithProject :one
INSERT INTO project_companies (
    project_id, company_id, association_notes, matching_score, approach_strategy
)
VALUES ($1, $2, $3, $4, $5)
RETURNING project_id, company_id, association_notes, matching_score, approach_strategy
`

type AssociateCompanyWithProjectParams struct {
	ProjectID        int32          `json:"project_id"`
	CompanyID        int32          `json:"company_id"`
	AssociationNotes sql.NullString `json:"association_notes"`
	MatchingScore    sql.NullString `json:"matching_score"`
	ApproachStrategy sql.NullString `json:"approach_strategy"`
}

func (q *Queries) AssociateCompanyWithProject(ctx context.Context, arg AssociateCompanyWithProjectParams) (ProjectCompany, error) {
	row := q.db.QueryRowContext(ctx, associateCompanyWithProject,
		arg.ProjectID,
		arg.CompanyID,
		arg.AssociationNotes,
		arg.MatchingScore,
		arg.ApproachStrategy,
	)
	var i ProjectCompany
	err := row.Scan(
		&i.ProjectID,
		&i.CompanyID,
		&i.AssociationNotes,
		&i.MatchingScore,
		&i.ApproachStrategy,
	)
	return i, err
}

const getProjectCompanyAssociation = `-- name: GetProjectCompanyAssociation :one
SELECT project_id, company_id, association_notes, matching_score, approach_strategy
FROM project_companies
WHERE project_id = $1 AND company_id = $2
`

type GetProjectCompanyAssociationParams struct {
	ProjectID int32 `json:"project_id"`
	CompanyID int32 `json:"company_id"`
}

func (q *Queries) GetProjectCompanyAssociation(ctx context.Context, arg GetProjectCompanyAssociationParams) (ProjectCompany, error) {
	row := q.db.QueryRowContext(ctx, getProjectCompanyAssociation, arg.ProjectID, arg.CompanyID)
	var i ProjectCompany
	err := row.Scan(
		&i.ProjectID,
		&i.CompanyID,
		&i.AssociationNotes,
		&i.MatchingScore,
		&i.ApproachStrategy,
	)
	return i, err
}

const listCompaniesForProject = `-- name: ListCompaniesForProject :many
SELECT pc.project_id, pc.company_id, pc.association_notes, pc.matching_score, pc.approach_strategy,
       c.name, c.industry, c.website
FROM project_companies pc
JOIN companies c ON pc.company_id = c.company_id
WHERE pc.project_id = $1
ORDER BY pc.matching_score DESC
LIMIT $2 OFFSET $3
`

type ListCompaniesForProjectParams struct {
	ProjectID int32 `json:"project_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListCompaniesForProjectRow struct {
	ProjectID        int32          `json:"project_id"`
	CompanyID        int32          `json:"company_id"`
	AssociationNotes sql.NullString `json:"association_notes"`
	MatchingScore    sql.NullString `json:"matching_score"`
	ApproachStrategy sql.NullString `json:"approach_strategy"`
	Name             string         `json:"name"`
	Industry         sql.NullString `json:"industry"`
	Website          sql.NullString `json:"website"`
}

func (q *Queries) ListCompaniesForProject(ctx context.Context, arg ListCompaniesForProjectParams) ([]ListCompaniesForProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, listCompaniesForProject, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCompaniesForProjectRow
	for rows.Next() {
		var i ListCompaniesForProjectRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.CompanyID,
			&i.AssociationNotes,
			&i.MatchingScore,
			&i.ApproachStrategy,
			&i.Name,
			&i.Industry,
			&i.Website,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectsForCompany = `-- name: ListProjectsForCompany :many
SELECT pc.project_id, pc.company_id, pc.association_notes, pc.matching_score, pc.approach_strategy,
       p.project_name, p.description
FROM project_companies pc
JOIN projects p ON pc.project_id = p.project_id
WHERE pc.company_id = $1
ORDER BY pc.matching_score DESC
LIMIT $2 OFFSET $3
`

type ListProjectsForCompanyParams struct {
	CompanyID int32 `json:"company_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListProjectsForCompanyRow struct {
	ProjectID        int32          `json:"project_id"`
	CompanyID        int32          `json:"company_id"`
	AssociationNotes sql.NullString `json:"association_notes"`
	MatchingScore    sql.NullString `json:"matching_score"`
	ApproachStrategy sql.NullString `json:"approach_strategy"`
	ProjectName      string         `json:"project_name"`
	Description      sql.NullString `json:"description"`
}

func (q *Queries) ListProjectsForCompany(ctx context.Context, arg ListProjectsForCompanyParams) ([]ListProjectsForCompanyRow, error) {
	rows, err := q.db.QueryContext(ctx, listProjectsForCompany, arg.CompanyID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProjectsForCompanyRow
	for rows.Next() {
		var i ListProjectsForCompanyRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.CompanyID,
			&i.AssociationNotes,
			&i.MatchingScore,
			&i.ApproachStrategy,
			&i.ProjectName,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeProjectCompanyAssociation = `-- name: RemoveProjectCompanyAssociation :exec
DELETE FROM project_companies
WHERE project_id = $1 AND company_id = $2
`

type RemoveProjectCompanyAssociationParams struct {
	ProjectID int32 `json:"project_id"`
	CompanyID int32 `json:"company_id"`
}

func (q *Queries) RemoveProjectCompanyAssociation(ctx context.Context, arg RemoveProjectCompanyAssociationParams) error {
	_, err := q.db.ExecContext(ctx, removeProjectCompanyAssociation, arg.ProjectID, arg.CompanyID)
	return err
}

const updateProjectCompanyAssociation = `-- name: UpdateProjectCompanyAssociation :one
UPDATE project_companies
SET association_notes = $3,
    matching_score = $4,
    approach_strategy = $5
WHERE project_id = $1 AND company_id = $2
RETURNING project_id, company_id, association_notes, matching_score, approach_strategy
`

type UpdateProjectCompanyAssociationParams struct {
	ProjectID        int32          `json:"project_id"`
	CompanyID        int32          `json:"company_id"`
	AssociationNotes sql.NullString `json:"association_notes"`
	MatchingScore    sql.NullString `json:"matching_score"`
	ApproachStrategy sql.NullString `json:"approach_strategy"`
}

func (q *Queries) UpdateProjectCompanyAssociation(ctx context.Context, arg UpdateProjectCompanyAssociationParams) (ProjectCompany, error) {
	row := q.db.QueryRowContext(ctx, updateProjectCompanyAssociation,
		arg.ProjectID,
		arg.CompanyID,
		arg.AssociationNotes,
		arg.MatchingScore,
		arg.ApproachStrategy,
	)
	var i ProjectCompany
	err := row.Scan(
		&i.ProjectID,
		&i.CompanyID,
		&i.AssociationNotes,
		&i.MatchingScore,
		&i.ApproachStrategy,
	)
	return i, err
}
