// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: project_files.sql

package db

import (
	"context"
	"database/sql"
)

const deleteProjectFile = `-- name: DeleteProjectFile :exec
DELETE FROM project_files
WHERE file_id = $1
`

func (q *Queries) DeleteProjectFile(ctx context.Context, fileID int32) error {
	_, err := q.db.ExecContext(ctx, deleteProjectFile, fileID)
	return err
}

const getFileByID = `-- name: GetFileByID :one
SELECT file_id, project_id, file_name, file_type, file_path, uploaded_at, file_size
FROM project_files
WHERE file_id = $1
`

func (q *Queries) GetFileByID(ctx context.Context, fileID int32) (ProjectFile, error) {
	row := q.db.QueryRowContext(ctx, getFileByID, fileID)
	var i ProjectFile
	err := row.Scan(
		&i.FileID,
		&i.ProjectID,
		&i.FileName,
		&i.FileType,
		&i.FilePath,
		&i.UploadedAt,
		&i.FileSize,
	)
	return i, err
}

const listFilesForProject = `-- name: ListFilesForProject :many
SELECT file_id, project_id, file_name, file_type, file_path, uploaded_at, file_size
FROM project_files
WHERE project_id = $1
ORDER BY uploaded_at DESC
LIMIT $2 OFFSET $3
`

type ListFilesForProjectParams struct {
	ProjectID sql.NullInt32 `json:"project_id"`
	Limit     int32         `json:"limit"`
	Offset    int32         `json:"offset"`
}

func (q *Queries) ListFilesForProject(ctx context.Context, arg ListFilesForProjectParams) ([]ProjectFile, error) {
	rows, err := q.db.QueryContext(ctx, listFilesForProject, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectFile
	for rows.Next() {
		var i ProjectFile
		if err := rows.Scan(
			&i.FileID,
			&i.ProjectID,
			&i.FileName,
			&i.FileType,
			&i.FilePath,
			&i.UploadedAt,
			&i.FileSize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProjectFileInfo = `-- name: UpdateProjectFileInfo :one
UPDATE project_files
SET file_name = $2,
    file_type = $3,
    file_path = $4,
    file_size = $5
WHERE file_id = $1
RETURNING file_id, project_id, file_name, file_type, file_path, uploaded_at, file_size
`

type UpdateProjectFileInfoParams struct {
	FileID   int32         `json:"file_id"`
	FileName string        `json:"file_name"`
	FileType string        `json:"file_type"`
	FilePath string        `json:"file_path"`
	FileSize sql.NullInt32 `json:"file_size"`
}

func (q *Queries) UpdateProjectFileInfo(ctx context.Context, arg UpdateProjectFileInfoParams) (ProjectFile, error) {
	row := q.db.QueryRowContext(ctx, updateProjectFileInfo,
		arg.FileID,
		arg.FileName,
		arg.FileType,
		arg.FilePath,
		arg.FileSize,
	)
	var i ProjectFile
	err := row.Scan(
		&i.FileID,
		&i.ProjectID,
		&i.FileName,
		&i.FileType,
		&i.FilePath,
		&i.UploadedAt,
		&i.FileSize,
	)
	return i, err
}

const uploadProjectFile = `-- name: UploadProjectFile :one
INSERT INTO project_files (
    project_id, file_name, file_type, file_path, file_size
)
VALUES ($1, $2, $3, $4, $5)
RETURNING file_id, project_id, file_name, file_type, file_path, uploaded_at, file_size
`

type UploadProjectFileParams struct {
	ProjectID sql.NullInt32 `json:"project_id"`
	FileName  string        `json:"file_name"`
	FileType  string        `json:"file_type"`
	FilePath  string        `json:"file_path"`
	FileSize  sql.NullInt32 `json:"file_size"`
}

func (q *Queries) UploadProjectFile(ctx context.Context, arg UploadProjectFileParams) (ProjectFile, error) {
	row := q.db.QueryRowContext(ctx, uploadProjectFile,
		arg.ProjectID,
		arg.FileName,
		arg.FileType,
		arg.FilePath,
		arg.FileSize,
	)
	var i ProjectFile
	err := row.Scan(
		&i.FileID,
		&i.ProjectID,
		&i.FileName,
		&i.FileType,
		&i.FilePath,
		&i.UploadedAt,
		&i.FileSize,
	)
	return i, err
}
