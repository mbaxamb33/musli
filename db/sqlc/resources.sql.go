// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: resources.sql

package db

import (
	"context"
	"database/sql"
)

const createResource = `-- name: CreateResource :one
INSERT INTO resources (
  name,
  description,
  category_id,
  unit,
  cost_per_unit
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING resource_id, name, description, category_id, unit, cost_per_unit, created_at, updated_at
`

type CreateResourceParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	CategoryID  sql.NullInt32  `json:"category_id"`
	Unit        sql.NullString `json:"unit"`
	CostPerUnit sql.NullString `json:"cost_per_unit"`
}

func (q *Queries) CreateResource(ctx context.Context, arg CreateResourceParams) (Resource, error) {
	row := q.db.QueryRowContext(ctx, createResource,
		arg.Name,
		arg.Description,
		arg.CategoryID,
		arg.Unit,
		arg.CostPerUnit,
	)
	var i Resource
	err := row.Scan(
		&i.ResourceID,
		&i.Name,
		&i.Description,
		&i.CategoryID,
		&i.Unit,
		&i.CostPerUnit,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteResource = `-- name: DeleteResource :exec
DELETE FROM resources
WHERE resource_id = $1
`

func (q *Queries) DeleteResource(ctx context.Context, resourceID int32) error {
	_, err := q.db.ExecContext(ctx, deleteResource, resourceID)
	return err
}

const getResource = `-- name: GetResource :one
SELECT resource_id, name, description, category_id, unit, cost_per_unit, created_at, updated_at FROM resources
WHERE resource_id = $1 LIMIT 1
`

func (q *Queries) GetResource(ctx context.Context, resourceID int32) (Resource, error) {
	row := q.db.QueryRowContext(ctx, getResource, resourceID)
	var i Resource
	err := row.Scan(
		&i.ResourceID,
		&i.Name,
		&i.Description,
		&i.CategoryID,
		&i.Unit,
		&i.CostPerUnit,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getResourcesUsedInProject = `-- name: GetResourcesUsedInProject :many
SELECT 
  r.resource_id, r.name, r.description, r.category_id, r.unit, r.cost_per_unit, r.created_at, r.updated_at,
  pr.quantity,
  pr.notes
FROM resources r
JOIN project_resources pr ON r.resource_id = pr.resource_id
WHERE pr.project_id = $1
ORDER BY r.name
`

type GetResourcesUsedInProjectRow struct {
	ResourceID  int32          `json:"resource_id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	CategoryID  sql.NullInt32  `json:"category_id"`
	Unit        sql.NullString `json:"unit"`
	CostPerUnit sql.NullString `json:"cost_per_unit"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
	Quantity    string         `json:"quantity"`
	Notes       sql.NullString `json:"notes"`
}

func (q *Queries) GetResourcesUsedInProject(ctx context.Context, projectID int32) ([]GetResourcesUsedInProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, getResourcesUsedInProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetResourcesUsedInProjectRow
	for rows.Next() {
		var i GetResourcesUsedInProjectRow
		if err := rows.Scan(
			&i.ResourceID,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.Unit,
			&i.CostPerUnit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Quantity,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResources = `-- name: ListResources :many
SELECT resource_id, name, description, category_id, unit, cost_per_unit, created_at, updated_at FROM resources
ORDER BY name
LIMIT $1 OFFSET $2
`

type ListResourcesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListResources(ctx context.Context, arg ListResourcesParams) ([]Resource, error) {
	rows, err := q.db.QueryContext(ctx, listResources, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Resource
	for rows.Next() {
		var i Resource
		if err := rows.Scan(
			&i.ResourceID,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.Unit,
			&i.CostPerUnit,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourcesByCategory = `-- name: ListResourcesByCategory :many
SELECT resource_id, name, description, category_id, unit, cost_per_unit, created_at, updated_at FROM resources
WHERE category_id = $1
ORDER BY name
LIMIT $2 OFFSET $3
`

type ListResourcesByCategoryParams struct {
	CategoryID sql.NullInt32 `json:"category_id"`
	Limit      int32         `json:"limit"`
	Offset     int32         `json:"offset"`
}

func (q *Queries) ListResourcesByCategory(ctx context.Context, arg ListResourcesByCategoryParams) ([]Resource, error) {
	rows, err := q.db.QueryContext(ctx, listResourcesByCategory, arg.CategoryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Resource
	for rows.Next() {
		var i Resource
		if err := rows.Scan(
			&i.ResourceID,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.Unit,
			&i.CostPerUnit,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourcesWithCategory = `-- name: ListResourcesWithCategory :many
SELECT 
  r.resource_id, r.name, r.description, r.category_id, r.unit, r.cost_per_unit, r.created_at, r.updated_at,
  rc.name AS category_name
FROM resources r
LEFT JOIN resource_categories rc ON r.category_id = rc.category_id
ORDER BY r.name
LIMIT $1 OFFSET $2
`

type ListResourcesWithCategoryParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListResourcesWithCategoryRow struct {
	ResourceID   int32          `json:"resource_id"`
	Name         string         `json:"name"`
	Description  sql.NullString `json:"description"`
	CategoryID   sql.NullInt32  `json:"category_id"`
	Unit         sql.NullString `json:"unit"`
	CostPerUnit  sql.NullString `json:"cost_per_unit"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	CategoryName sql.NullString `json:"category_name"`
}

func (q *Queries) ListResourcesWithCategory(ctx context.Context, arg ListResourcesWithCategoryParams) ([]ListResourcesWithCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, listResourcesWithCategory, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListResourcesWithCategoryRow
	for rows.Next() {
		var i ListResourcesWithCategoryRow
		if err := rows.Scan(
			&i.ResourceID,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.Unit,
			&i.CostPerUnit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchResources = `-- name: SearchResources :many
SELECT resource_id, name, description, category_id, unit, cost_per_unit, created_at, updated_at FROM resources
WHERE name ILIKE '%' || $1 || '%' OR description ILIKE '%' || $1 || '%'
ORDER BY name
LIMIT $2 OFFSET $3
`

type SearchResourcesParams struct {
	Column1 sql.NullString `json:"column_1"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

func (q *Queries) SearchResources(ctx context.Context, arg SearchResourcesParams) ([]Resource, error) {
	rows, err := q.db.QueryContext(ctx, searchResources, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Resource
	for rows.Next() {
		var i Resource
		if err := rows.Scan(
			&i.ResourceID,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.Unit,
			&i.CostPerUnit,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateResource = `-- name: UpdateResource :one
UPDATE resources
SET
  name = COALESCE($2, name),
  description = COALESCE($3, description),
  category_id = COALESCE($4, category_id),
  unit = COALESCE($5, unit),
  cost_per_unit = COALESCE($6, cost_per_unit),
  updated_at = CURRENT_TIMESTAMP
WHERE resource_id = $1
RETURNING resource_id, name, description, category_id, unit, cost_per_unit, created_at, updated_at
`

type UpdateResourceParams struct {
	ResourceID  int32          `json:"resource_id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	CategoryID  sql.NullInt32  `json:"category_id"`
	Unit        sql.NullString `json:"unit"`
	CostPerUnit sql.NullString `json:"cost_per_unit"`
}

func (q *Queries) UpdateResource(ctx context.Context, arg UpdateResourceParams) (Resource, error) {
	row := q.db.QueryRowContext(ctx, updateResource,
		arg.ResourceID,
		arg.Name,
		arg.Description,
		arg.CategoryID,
		arg.Unit,
		arg.CostPerUnit,
	)
	var i Resource
	err := row.Scan(
		&i.ResourceID,
		&i.Name,
		&i.Description,
		&i.CategoryID,
		&i.Unit,
		&i.CostPerUnit,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
