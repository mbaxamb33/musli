// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: combined_data_queries.sql

package db

import (
	"context"
	"database/sql"
)

const getCompanyAllData = `-- name: GetCompanyAllData :many
SELECT c.company_id, c.company_name, c.industry, c.website, c.description,
       d.datasource_id, d.source_type, d.link, d.file_name,
       p.paragraph_id, p.title, p.main_idea, p.content
FROM companies c
JOIN company_datasources cd ON c.company_id = cd.company_id
JOIN datasources d ON cd.datasource_id = d.datasource_id
LEFT JOIN paragraphs p ON d.datasource_id = p.datasource_id
WHERE c.company_id = $1
ORDER BY d.created_at DESC, p.paragraph_id ASC
`

type GetCompanyAllDataRow struct {
	CompanyID    int32          `json:"company_id"`
	CompanyName  string         `json:"company_name"`
	Industry     sql.NullString `json:"industry"`
	Website      sql.NullString `json:"website"`
	Description  sql.NullString `json:"description"`
	DatasourceID int32          `json:"datasource_id"`
	SourceType   DatasourceType `json:"source_type"`
	Link         sql.NullString `json:"link"`
	FileName     sql.NullString `json:"file_name"`
	ParagraphID  sql.NullInt32  `json:"paragraph_id"`
	Title        sql.NullString `json:"title"`
	MainIdea     sql.NullString `json:"main_idea"`
	Content      sql.NullString `json:"content"`
}

func (q *Queries) GetCompanyAllData(ctx context.Context, companyID int32) ([]GetCompanyAllDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getCompanyAllData, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompanyAllDataRow
	for rows.Next() {
		var i GetCompanyAllDataRow
		if err := rows.Scan(
			&i.CompanyID,
			&i.CompanyName,
			&i.Industry,
			&i.Website,
			&i.Description,
			&i.DatasourceID,
			&i.SourceType,
			&i.Link,
			&i.FileName,
			&i.ParagraphID,
			&i.Title,
			&i.MainIdea,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyParagraphs = `-- name: GetCompanyParagraphs :many
SELECT c.company_id, c.company_name, d.datasource_id, d.source_type, 
       p.paragraph_id, p.title, p.main_idea, p.content, p.created_at
FROM companies c
JOIN company_datasources cd ON c.company_id = cd.company_id
JOIN datasources d ON cd.datasource_id = d.datasource_id
JOIN paragraphs p ON d.datasource_id = p.datasource_id
WHERE c.company_id = $1
ORDER BY d.created_at DESC, p.paragraph_id ASC
LIMIT $2 OFFSET $3
`

type GetCompanyParagraphsParams struct {
	CompanyID int32 `json:"company_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type GetCompanyParagraphsRow struct {
	CompanyID    int32          `json:"company_id"`
	CompanyName  string         `json:"company_name"`
	DatasourceID int32          `json:"datasource_id"`
	SourceType   DatasourceType `json:"source_type"`
	ParagraphID  int32          `json:"paragraph_id"`
	Title        sql.NullString `json:"title"`
	MainIdea     sql.NullString `json:"main_idea"`
	Content      string         `json:"content"`
	CreatedAt    sql.NullTime   `json:"created_at"`
}

func (q *Queries) GetCompanyParagraphs(ctx context.Context, arg GetCompanyParagraphsParams) ([]GetCompanyParagraphsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCompanyParagraphs, arg.CompanyID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompanyParagraphsRow
	for rows.Next() {
		var i GetCompanyParagraphsRow
		if err := rows.Scan(
			&i.CompanyID,
			&i.CompanyName,
			&i.DatasourceID,
			&i.SourceType,
			&i.ParagraphID,
			&i.Title,
			&i.MainIdea,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyWithDatasources = `-- name: GetCompanyWithDatasources :many
SELECT c.company_id, c.company_name, c.industry, c.website, 
       d.datasource_id, d.source_type, d.link, d.file_name, d.created_at as datasource_created_at
FROM companies c
JOIN company_datasources cd ON c.company_id = cd.company_id
JOIN datasources d ON cd.datasource_id = d.datasource_id
WHERE c.company_id = $1
ORDER BY d.created_at DESC
`

type GetCompanyWithDatasourcesRow struct {
	CompanyID           int32          `json:"company_id"`
	CompanyName         string         `json:"company_name"`
	Industry            sql.NullString `json:"industry"`
	Website             sql.NullString `json:"website"`
	DatasourceID        int32          `json:"datasource_id"`
	SourceType          DatasourceType `json:"source_type"`
	Link                sql.NullString `json:"link"`
	FileName            sql.NullString `json:"file_name"`
	DatasourceCreatedAt sql.NullTime   `json:"datasource_created_at"`
}

func (q *Queries) GetCompanyWithDatasources(ctx context.Context, companyID int32) ([]GetCompanyWithDatasourcesRow, error) {
	rows, err := q.db.QueryContext(ctx, getCompanyWithDatasources, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompanyWithDatasourcesRow
	for rows.Next() {
		var i GetCompanyWithDatasourcesRow
		if err := rows.Scan(
			&i.CompanyID,
			&i.CompanyName,
			&i.Industry,
			&i.Website,
			&i.DatasourceID,
			&i.SourceType,
			&i.Link,
			&i.FileName,
			&i.DatasourceCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContactAllData = `-- name: GetContactAllData :many
SELECT ct.contact_id, ct.first_name, ct.last_name, ct.position, ct.email, ct.notes,
       d.datasource_id, d.source_type, d.link, d.file_name, 
       p.paragraph_id, p.title, p.main_idea, p.content
FROM contacts ct
JOIN contact_datasources cd ON ct.contact_id = cd.contact_id
JOIN datasources d ON cd.datasource_id = d.datasource_id
LEFT JOIN paragraphs p ON d.datasource_id = p.datasource_id
WHERE ct.contact_id = $1
ORDER BY d.created_at DESC, p.paragraph_id ASC
`

type GetContactAllDataRow struct {
	ContactID    int32          `json:"contact_id"`
	FirstName    string         `json:"first_name"`
	LastName     string         `json:"last_name"`
	Position     sql.NullString `json:"position"`
	Email        sql.NullString `json:"email"`
	Notes        sql.NullString `json:"notes"`
	DatasourceID int32          `json:"datasource_id"`
	SourceType   DatasourceType `json:"source_type"`
	Link         sql.NullString `json:"link"`
	FileName     sql.NullString `json:"file_name"`
	ParagraphID  sql.NullInt32  `json:"paragraph_id"`
	Title        sql.NullString `json:"title"`
	MainIdea     sql.NullString `json:"main_idea"`
	Content      sql.NullString `json:"content"`
}

func (q *Queries) GetContactAllData(ctx context.Context, contactID int32) ([]GetContactAllDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getContactAllData, contactID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContactAllDataRow
	for rows.Next() {
		var i GetContactAllDataRow
		if err := rows.Scan(
			&i.ContactID,
			&i.FirstName,
			&i.LastName,
			&i.Position,
			&i.Email,
			&i.Notes,
			&i.DatasourceID,
			&i.SourceType,
			&i.Link,
			&i.FileName,
			&i.ParagraphID,
			&i.Title,
			&i.MainIdea,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContactParagraphs = `-- name: GetContactParagraphs :many
SELECT ct.contact_id, ct.first_name, ct.last_name, d.datasource_id, d.source_type,
       p.paragraph_id, p.title, p.main_idea, p.content, p.created_at
FROM contacts ct
JOIN contact_datasources cd ON ct.contact_id = cd.contact_id
JOIN datasources d ON cd.datasource_id = d.datasource_id
JOIN paragraphs p ON d.datasource_id = p.datasource_id
WHERE ct.contact_id = $1
ORDER BY d.created_at DESC, p.paragraph_id ASC
LIMIT $2 OFFSET $3
`

type GetContactParagraphsParams struct {
	ContactID int32 `json:"contact_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type GetContactParagraphsRow struct {
	ContactID    int32          `json:"contact_id"`
	FirstName    string         `json:"first_name"`
	LastName     string         `json:"last_name"`
	DatasourceID int32          `json:"datasource_id"`
	SourceType   DatasourceType `json:"source_type"`
	ParagraphID  int32          `json:"paragraph_id"`
	Title        sql.NullString `json:"title"`
	MainIdea     sql.NullString `json:"main_idea"`
	Content      string         `json:"content"`
	CreatedAt    sql.NullTime   `json:"created_at"`
}

func (q *Queries) GetContactParagraphs(ctx context.Context, arg GetContactParagraphsParams) ([]GetContactParagraphsRow, error) {
	rows, err := q.db.QueryContext(ctx, getContactParagraphs, arg.ContactID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContactParagraphsRow
	for rows.Next() {
		var i GetContactParagraphsRow
		if err := rows.Scan(
			&i.ContactID,
			&i.FirstName,
			&i.LastName,
			&i.DatasourceID,
			&i.SourceType,
			&i.ParagraphID,
			&i.Title,
			&i.MainIdea,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContactWithDatasources = `-- name: GetContactWithDatasources :many
SELECT ct.contact_id, ct.first_name, ct.last_name, ct.position, ct.email,
       d.datasource_id, d.source_type, d.link, d.file_name, d.created_at as datasource_created_at
FROM contacts ct
JOIN contact_datasources cd ON ct.contact_id = cd.contact_id
JOIN datasources d ON cd.datasource_id = d.datasource_id
WHERE ct.contact_id = $1
ORDER BY d.created_at DESC
`

type GetContactWithDatasourcesRow struct {
	ContactID           int32          `json:"contact_id"`
	FirstName           string         `json:"first_name"`
	LastName            string         `json:"last_name"`
	Position            sql.NullString `json:"position"`
	Email               sql.NullString `json:"email"`
	DatasourceID        int32          `json:"datasource_id"`
	SourceType          DatasourceType `json:"source_type"`
	Link                sql.NullString `json:"link"`
	FileName            sql.NullString `json:"file_name"`
	DatasourceCreatedAt sql.NullTime   `json:"datasource_created_at"`
}

func (q *Queries) GetContactWithDatasources(ctx context.Context, contactID int32) ([]GetContactWithDatasourcesRow, error) {
	rows, err := q.db.QueryContext(ctx, getContactWithDatasources, contactID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContactWithDatasourcesRow
	for rows.Next() {
		var i GetContactWithDatasourcesRow
		if err := rows.Scan(
			&i.ContactID,
			&i.FirstName,
			&i.LastName,
			&i.Position,
			&i.Email,
			&i.DatasourceID,
			&i.SourceType,
			&i.Link,
			&i.FileName,
			&i.DatasourceCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCompanyParagraphs = `-- name: SearchCompanyParagraphs :many
SELECT c.company_id, c.company_name, d.datasource_id, d.source_type, 
       p.paragraph_id, p.title, p.main_idea, p.content
FROM companies c
JOIN company_datasources cd ON c.company_id = cd.company_id
JOIN datasources d ON cd.datasource_id = d.datasource_id
JOIN paragraphs p ON d.datasource_id = p.datasource_id
WHERE c.company_id = $1 AND (p.content ILIKE '%' || $2 || '%' OR p.main_idea ILIKE '%' || $2 || '%')
ORDER BY p.created_at DESC
LIMIT $3 OFFSET $4
`

type SearchCompanyParagraphsParams struct {
	CompanyID int32          `json:"company_id"`
	Column2   sql.NullString `json:"column_2"`
	Limit     int32          `json:"limit"`
	Offset    int32          `json:"offset"`
}

type SearchCompanyParagraphsRow struct {
	CompanyID    int32          `json:"company_id"`
	CompanyName  string         `json:"company_name"`
	DatasourceID int32          `json:"datasource_id"`
	SourceType   DatasourceType `json:"source_type"`
	ParagraphID  int32          `json:"paragraph_id"`
	Title        sql.NullString `json:"title"`
	MainIdea     sql.NullString `json:"main_idea"`
	Content      string         `json:"content"`
}

func (q *Queries) SearchCompanyParagraphs(ctx context.Context, arg SearchCompanyParagraphsParams) ([]SearchCompanyParagraphsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchCompanyParagraphs,
		arg.CompanyID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchCompanyParagraphsRow
	for rows.Next() {
		var i SearchCompanyParagraphsRow
		if err := rows.Scan(
			&i.CompanyID,
			&i.CompanyName,
			&i.DatasourceID,
			&i.SourceType,
			&i.ParagraphID,
			&i.Title,
			&i.MainIdea,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchContactParagraphs = `-- name: SearchContactParagraphs :many
SELECT ct.contact_id, ct.first_name, ct.last_name, d.datasource_id, d.source_type,
       p.paragraph_id, p.title, p.main_idea, p.content
FROM contacts ct
JOIN contact_datasources cd ON ct.contact_id = cd.contact_id
JOIN datasources d ON cd.datasource_id = d.datasource_id
JOIN paragraphs p ON d.datasource_id = p.datasource_id
WHERE ct.contact_id = $1 AND (p.content ILIKE '%' || $2 || '%' OR p.main_idea ILIKE '%' || $2 || '%')
ORDER BY p.created_at DESC
LIMIT $3 OFFSET $4
`

type SearchContactParagraphsParams struct {
	ContactID int32          `json:"contact_id"`
	Column2   sql.NullString `json:"column_2"`
	Limit     int32          `json:"limit"`
	Offset    int32          `json:"offset"`
}

type SearchContactParagraphsRow struct {
	ContactID    int32          `json:"contact_id"`
	FirstName    string         `json:"first_name"`
	LastName     string         `json:"last_name"`
	DatasourceID int32          `json:"datasource_id"`
	SourceType   DatasourceType `json:"source_type"`
	ParagraphID  int32          `json:"paragraph_id"`
	Title        sql.NullString `json:"title"`
	MainIdea     sql.NullString `json:"main_idea"`
	Content      string         `json:"content"`
}

func (q *Queries) SearchContactParagraphs(ctx context.Context, arg SearchContactParagraphsParams) ([]SearchContactParagraphsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchContactParagraphs,
		arg.ContactID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchContactParagraphsRow
	for rows.Next() {
		var i SearchContactParagraphsRow
		if err := rows.Scan(
			&i.ContactID,
			&i.FirstName,
			&i.LastName,
			&i.DatasourceID,
			&i.SourceType,
			&i.ParagraphID,
			&i.Title,
			&i.MainIdea,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
