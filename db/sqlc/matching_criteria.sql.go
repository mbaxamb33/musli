// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: matching_criteria.sql

package db

import (
	"context"
	"database/sql"
)

const createMatchingCriteria = `-- name: CreateMatchingCriteria :one
INSERT INTO matching_criteria (
  name,
  description,
  weight,
  is_active
) VALUES (
  $1, $2, $3, $4
) RETURNING criteria_id, name, description, weight, is_active, created_at, updated_at
`

type CreateMatchingCriteriaParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	Weight      sql.NullString `json:"weight"`
	IsActive    sql.NullBool   `json:"is_active"`
}

func (q *Queries) CreateMatchingCriteria(ctx context.Context, arg CreateMatchingCriteriaParams) (MatchingCriterium, error) {
	row := q.db.QueryRowContext(ctx, createMatchingCriteria,
		arg.Name,
		arg.Description,
		arg.Weight,
		arg.IsActive,
	)
	var i MatchingCriterium
	err := row.Scan(
		&i.CriteriaID,
		&i.Name,
		&i.Description,
		&i.Weight,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteMatchingCriteria = `-- name: DeleteMatchingCriteria :exec
DELETE FROM matching_criteria
WHERE criteria_id = $1
`

func (q *Queries) DeleteMatchingCriteria(ctx context.Context, criteriaID int32) error {
	_, err := q.db.ExecContext(ctx, deleteMatchingCriteria, criteriaID)
	return err
}

const getMatchingCriteria = `-- name: GetMatchingCriteria :one
SELECT criteria_id, name, description, weight, is_active, created_at, updated_at FROM matching_criteria
WHERE criteria_id = $1 LIMIT 1
`

func (q *Queries) GetMatchingCriteria(ctx context.Context, criteriaID int32) (MatchingCriterium, error) {
	row := q.db.QueryRowContext(ctx, getMatchingCriteria, criteriaID)
	var i MatchingCriterium
	err := row.Scan(
		&i.CriteriaID,
		&i.Name,
		&i.Description,
		&i.Weight,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMatchingCriteriaByName = `-- name: GetMatchingCriteriaByName :one
SELECT criteria_id, name, description, weight, is_active, created_at, updated_at FROM matching_criteria
WHERE name = $1 LIMIT 1
`

func (q *Queries) GetMatchingCriteriaByName(ctx context.Context, name string) (MatchingCriterium, error) {
	row := q.db.QueryRowContext(ctx, getMatchingCriteriaByName, name)
	var i MatchingCriterium
	err := row.Scan(
		&i.CriteriaID,
		&i.Name,
		&i.Description,
		&i.Weight,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMatchingCriteriaWithUsageCount = `-- name: GetMatchingCriteriaWithUsageCount :many
SELECT 
  mc.criteria_id, mc.name, mc.description, mc.weight, mc.is_active, mc.created_at, mc.updated_at,
  COUNT(msd.score_detail_id) AS usage_count
FROM matching_criteria mc
LEFT JOIN matching_scores_detail msd ON mc.criteria_id = msd.criteria_id
GROUP BY mc.criteria_id
ORDER BY mc.weight DESC, mc.name
LIMIT $1 OFFSET $2
`

type GetMatchingCriteriaWithUsageCountParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetMatchingCriteriaWithUsageCountRow struct {
	CriteriaID  int32          `json:"criteria_id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	Weight      sql.NullString `json:"weight"`
	IsActive    sql.NullBool   `json:"is_active"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
	UsageCount  int64          `json:"usage_count"`
}

func (q *Queries) GetMatchingCriteriaWithUsageCount(ctx context.Context, arg GetMatchingCriteriaWithUsageCountParams) ([]GetMatchingCriteriaWithUsageCountRow, error) {
	rows, err := q.db.QueryContext(ctx, getMatchingCriteriaWithUsageCount, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMatchingCriteriaWithUsageCountRow
	for rows.Next() {
		var i GetMatchingCriteriaWithUsageCountRow
		if err := rows.Scan(
			&i.CriteriaID,
			&i.Name,
			&i.Description,
			&i.Weight,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UsageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalCriteriaWeight = `-- name: GetTotalCriteriaWeight :one
SELECT SUM(weight) AS total_weight
FROM matching_criteria
WHERE is_active = TRUE
`

func (q *Queries) GetTotalCriteriaWeight(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalCriteriaWeight)
	var total_weight int64
	err := row.Scan(&total_weight)
	return total_weight, err
}

const listActiveMatchingCriteria = `-- name: ListActiveMatchingCriteria :many
SELECT criteria_id, name, description, weight, is_active, created_at, updated_at FROM matching_criteria
WHERE is_active = TRUE
ORDER BY weight DESC, name
LIMIT $1 OFFSET $2
`

type ListActiveMatchingCriteriaParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListActiveMatchingCriteria(ctx context.Context, arg ListActiveMatchingCriteriaParams) ([]MatchingCriterium, error) {
	rows, err := q.db.QueryContext(ctx, listActiveMatchingCriteria, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MatchingCriterium
	for rows.Next() {
		var i MatchingCriterium
		if err := rows.Scan(
			&i.CriteriaID,
			&i.Name,
			&i.Description,
			&i.Weight,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMatchingCriteria = `-- name: ListMatchingCriteria :many
SELECT criteria_id, name, description, weight, is_active, created_at, updated_at FROM matching_criteria
ORDER BY weight DESC, name
LIMIT $1 OFFSET $2
`

type ListMatchingCriteriaParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListMatchingCriteria(ctx context.Context, arg ListMatchingCriteriaParams) ([]MatchingCriterium, error) {
	rows, err := q.db.QueryContext(ctx, listMatchingCriteria, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MatchingCriterium
	for rows.Next() {
		var i MatchingCriterium
		if err := rows.Scan(
			&i.CriteriaID,
			&i.Name,
			&i.Description,
			&i.Weight,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleCriteriaActive = `-- name: ToggleCriteriaActive :one
UPDATE matching_criteria
SET 
  is_active = NOT is_active,
  updated_at = CURRENT_TIMESTAMP
WHERE criteria_id = $1
RETURNING criteria_id, name, description, weight, is_active, created_at, updated_at
`

func (q *Queries) ToggleCriteriaActive(ctx context.Context, criteriaID int32) (MatchingCriterium, error) {
	row := q.db.QueryRowContext(ctx, toggleCriteriaActive, criteriaID)
	var i MatchingCriterium
	err := row.Scan(
		&i.CriteriaID,
		&i.Name,
		&i.Description,
		&i.Weight,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMatchingCriteria = `-- name: UpdateMatchingCriteria :one
UPDATE matching_criteria
SET
  name = COALESCE($2, name),
  description = COALESCE($3, description),
  weight = COALESCE($4, weight),
  is_active = COALESCE($5, is_active),
  updated_at = CURRENT_TIMESTAMP
WHERE criteria_id = $1
RETURNING criteria_id, name, description, weight, is_active, created_at, updated_at
`

type UpdateMatchingCriteriaParams struct {
	CriteriaID  int32          `json:"criteria_id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	Weight      sql.NullString `json:"weight"`
	IsActive    sql.NullBool   `json:"is_active"`
}

func (q *Queries) UpdateMatchingCriteria(ctx context.Context, arg UpdateMatchingCriteriaParams) (MatchingCriterium, error) {
	row := q.db.QueryRowContext(ctx, updateMatchingCriteria,
		arg.CriteriaID,
		arg.Name,
		arg.Description,
		arg.Weight,
		arg.IsActive,
	)
	var i MatchingCriterium
	err := row.Scan(
		&i.CriteriaID,
		&i.Name,
		&i.Description,
		&i.Weight,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
