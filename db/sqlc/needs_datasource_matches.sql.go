// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: needs_datasource_matches.sql

package db

import (
	"context"
)

const createNeedsDatasourceMatch = `-- name: CreateNeedsDatasourceMatch :one
INSERT INTO needs_datasource_matches (
    need_id, datasource_id, match_score
)
VALUES ($1, $2, $3)
RETURNING match_id, need_id, datasource_id, match_score, created_at
`

type CreateNeedsDatasourceMatchParams struct {
	NeedID       int32  `json:"need_id"`
	DatasourceID int32  `json:"datasource_id"`
	MatchScore   string `json:"match_score"`
}

func (q *Queries) CreateNeedsDatasourceMatch(ctx context.Context, arg CreateNeedsDatasourceMatchParams) (NeedsDatasourceMatch, error) {
	row := q.db.QueryRowContext(ctx, createNeedsDatasourceMatch, arg.NeedID, arg.DatasourceID, arg.MatchScore)
	var i NeedsDatasourceMatch
	err := row.Scan(
		&i.MatchID,
		&i.NeedID,
		&i.DatasourceID,
		&i.MatchScore,
		&i.CreatedAt,
	)
	return i, err
}

const deleteNeedsDatasourceMatch = `-- name: DeleteNeedsDatasourceMatch :exec
DELETE FROM needs_datasource_matches
WHERE match_id = $1
`

func (q *Queries) DeleteNeedsDatasourceMatch(ctx context.Context, matchID int32) error {
	_, err := q.db.ExecContext(ctx, deleteNeedsDatasourceMatch, matchID)
	return err
}

const getNeedsDatasourceMatchByID = `-- name: GetNeedsDatasourceMatchByID :one
SELECT match_id, need_id, datasource_id, match_score, created_at
FROM needs_datasource_matches
WHERE match_id = $1
`

func (q *Queries) GetNeedsDatasourceMatchByID(ctx context.Context, matchID int32) (NeedsDatasourceMatch, error) {
	row := q.db.QueryRowContext(ctx, getNeedsDatasourceMatchByID, matchID)
	var i NeedsDatasourceMatch
	err := row.Scan(
		&i.MatchID,
		&i.NeedID,
		&i.DatasourceID,
		&i.MatchScore,
		&i.CreatedAt,
	)
	return i, err
}

const listMatchesByDatasource = `-- name: ListMatchesByDatasource :many
SELECT match_id, need_id, datasource_id, match_score, created_at
FROM needs_datasource_matches
WHERE datasource_id = $1
ORDER BY match_score DESC
LIMIT $2 OFFSET $3
`

type ListMatchesByDatasourceParams struct {
	DatasourceID int32 `json:"datasource_id"`
	Limit        int32 `json:"limit"`
	Offset       int32 `json:"offset"`
}

func (q *Queries) ListMatchesByDatasource(ctx context.Context, arg ListMatchesByDatasourceParams) ([]NeedsDatasourceMatch, error) {
	rows, err := q.db.QueryContext(ctx, listMatchesByDatasource, arg.DatasourceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NeedsDatasourceMatch
	for rows.Next() {
		var i NeedsDatasourceMatch
		if err := rows.Scan(
			&i.MatchID,
			&i.NeedID,
			&i.DatasourceID,
			&i.MatchScore,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMatchesByNeed = `-- name: ListMatchesByNeed :many
SELECT match_id, need_id, datasource_id, match_score, created_at
FROM needs_datasource_matches
WHERE need_id = $1
ORDER BY match_score DESC
LIMIT $2 OFFSET $3
`

type ListMatchesByNeedParams struct {
	NeedID int32 `json:"need_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListMatchesByNeed(ctx context.Context, arg ListMatchesByNeedParams) ([]NeedsDatasourceMatch, error) {
	rows, err := q.db.QueryContext(ctx, listMatchesByNeed, arg.NeedID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NeedsDatasourceMatch
	for rows.Next() {
		var i NeedsDatasourceMatch
		if err := rows.Scan(
			&i.MatchID,
			&i.NeedID,
			&i.DatasourceID,
			&i.MatchScore,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNeedsDatasourceMatch = `-- name: UpdateNeedsDatasourceMatch :one
UPDATE needs_datasource_matches
SET match_score = $3
WHERE need_id = $1 AND datasource_id = $2
RETURNING match_id, need_id, datasource_id, match_score, created_at
`

type UpdateNeedsDatasourceMatchParams struct {
	NeedID       int32  `json:"need_id"`
	DatasourceID int32  `json:"datasource_id"`
	MatchScore   string `json:"match_score"`
}

func (q *Queries) UpdateNeedsDatasourceMatch(ctx context.Context, arg UpdateNeedsDatasourceMatchParams) (NeedsDatasourceMatch, error) {
	row := q.db.QueryRowContext(ctx, updateNeedsDatasourceMatch, arg.NeedID, arg.DatasourceID, arg.MatchScore)
	var i NeedsDatasourceMatch
	err := row.Scan(
		&i.MatchID,
		&i.NeedID,
		&i.DatasourceID,
		&i.MatchScore,
		&i.CreatedAt,
	)
	return i, err
}
