// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: datasources.sql

package db

import (
	"context"
	"database/sql"
)

const createDatasource = `-- name: CreateDatasource :one
INSERT INTO datasources (
    source_type, source_id
)
VALUES ($1, $2)
RETURNING datasource_id, source_type, source_id, extraction_timestamp
`

type CreateDatasourceParams struct {
	SourceType string        `json:"source_type"`
	SourceID   sql.NullInt32 `json:"source_id"`
}

func (q *Queries) CreateDatasource(ctx context.Context, arg CreateDatasourceParams) (Datasource, error) {
	row := q.db.QueryRowContext(ctx, createDatasource, arg.SourceType, arg.SourceID)
	var i Datasource
	err := row.Scan(
		&i.DatasourceID,
		&i.SourceType,
		&i.SourceID,
		&i.ExtractionTimestamp,
	)
	return i, err
}

const deleteDatasource = `-- name: DeleteDatasource :exec
DELETE FROM datasources
WHERE datasource_id = $1
`

func (q *Queries) DeleteDatasource(ctx context.Context, datasourceID int32) error {
	_, err := q.db.ExecContext(ctx, deleteDatasource, datasourceID)
	return err
}

const getDatasourceByID = `-- name: GetDatasourceByID :one
SELECT datasource_id, source_type, source_id, extraction_timestamp
FROM datasources
WHERE datasource_id = $1
`

func (q *Queries) GetDatasourceByID(ctx context.Context, datasourceID int32) (Datasource, error) {
	row := q.db.QueryRowContext(ctx, getDatasourceByID, datasourceID)
	var i Datasource
	err := row.Scan(
		&i.DatasourceID,
		&i.SourceType,
		&i.SourceID,
		&i.ExtractionTimestamp,
	)
	return i, err
}

const listDatasources = `-- name: ListDatasources :many
SELECT datasource_id, source_type, source_id, extraction_timestamp
FROM datasources
ORDER BY extraction_timestamp DESC
LIMIT $1 OFFSET $2
`

type ListDatasourcesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListDatasources(ctx context.Context, arg ListDatasourcesParams) ([]Datasource, error) {
	rows, err := q.db.QueryContext(ctx, listDatasources, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Datasource
	for rows.Next() {
		var i Datasource
		if err := rows.Scan(
			&i.DatasourceID,
			&i.SourceType,
			&i.SourceID,
			&i.ExtractionTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDatasourcesByType = `-- name: ListDatasourcesByType :many
SELECT datasource_id, source_type, source_id, extraction_timestamp
FROM datasources
WHERE source_type = $1
ORDER BY extraction_timestamp DESC
LIMIT $2 OFFSET $3
`

type ListDatasourcesByTypeParams struct {
	SourceType string `json:"source_type"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

func (q *Queries) ListDatasourcesByType(ctx context.Context, arg ListDatasourcesByTypeParams) ([]Datasource, error) {
	rows, err := q.db.QueryContext(ctx, listDatasourcesByType, arg.SourceType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Datasource
	for rows.Next() {
		var i Datasource
		if err := rows.Scan(
			&i.DatasourceID,
			&i.SourceType,
			&i.SourceID,
			&i.ExtractionTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
